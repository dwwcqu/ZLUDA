/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct CUstream_st {
    _unused: [u8; 0],
}
#[doc = " CUDA stream"]
pub type cudaStream_t = *mut CUstream_st;
impl libraryPropertyType_t {
    pub const MAJOR_VERSION: libraryPropertyType_t = libraryPropertyType_t(0);
}
impl libraryPropertyType_t {
    pub const MINOR_VERSION: libraryPropertyType_t = libraryPropertyType_t(1);
}
impl libraryPropertyType_t {
    pub const PATCH_LEVEL: libraryPropertyType_t = libraryPropertyType_t(2);
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct libraryPropertyType_t(pub ::std::os::raw::c_uint);
pub use self::libraryPropertyType_t as libraryPropertyType;
impl curandStatus {
    #[doc = "< No errors"]
    pub const CURAND_STATUS_SUCCESS: curandStatus = curandStatus(0);
}
impl curandStatus {
    #[doc = "< Header file and linked library version do not match"]
    pub const CURAND_STATUS_VERSION_MISMATCH: curandStatus = curandStatus(100);
}
impl curandStatus {
    #[doc = "< Generator not initialized"]
    pub const CURAND_STATUS_NOT_INITIALIZED: curandStatus = curandStatus(101);
}
impl curandStatus {
    #[doc = "< Memory allocation failed"]
    pub const CURAND_STATUS_ALLOCATION_FAILED: curandStatus = curandStatus(102);
}
impl curandStatus {
    #[doc = "< Generator is wrong type"]
    pub const CURAND_STATUS_TYPE_ERROR: curandStatus = curandStatus(103);
}
impl curandStatus {
    #[doc = "< Argument out of range"]
    pub const CURAND_STATUS_OUT_OF_RANGE: curandStatus = curandStatus(104);
}
impl curandStatus {
    #[doc = "< Length requested is not a multple of dimension"]
    pub const CURAND_STATUS_LENGTH_NOT_MULTIPLE: curandStatus = curandStatus(105);
}
impl curandStatus {
    #[doc = "< GPU does not have double precision required by MRG32k3a"]
    pub const CURAND_STATUS_DOUBLE_PRECISION_REQUIRED: curandStatus = curandStatus(106);
}
impl curandStatus {
    #[doc = "< Kernel launch failure"]
    pub const CURAND_STATUS_LAUNCH_FAILURE: curandStatus = curandStatus(201);
}
impl curandStatus {
    #[doc = "< Preexisting failure on library entry"]
    pub const CURAND_STATUS_PREEXISTING_FAILURE: curandStatus = curandStatus(202);
}
impl curandStatus {
    #[doc = "< Initialization of CUDA failed"]
    pub const CURAND_STATUS_INITIALIZATION_FAILED: curandStatus = curandStatus(203);
}
impl curandStatus {
    #[doc = "< Architecture mismatch, GPU does not support requested feature"]
    pub const CURAND_STATUS_ARCH_MISMATCH: curandStatus = curandStatus(204);
}
impl curandStatus {
    #[doc = "< Internal library error"]
    pub const CURAND_STATUS_INTERNAL_ERROR: curandStatus = curandStatus(999);
}
#[repr(transparent)]
#[doc = " CURAND function call status types"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct curandStatus(pub ::std::os::raw::c_uint);
#[doc = " \\cond UNHIDE_TYPEDEFS"]
pub use self::curandStatus as curandStatus_t;
impl curandRngType {
    pub const CURAND_RNG_TEST: curandRngType = curandRngType(0);
}
impl curandRngType {
    #[doc = "< Default pseudorandom generator"]
    pub const CURAND_RNG_PSEUDO_DEFAULT: curandRngType = curandRngType(100);
}
impl curandRngType {
    #[doc = "< XORWOW pseudorandom generator"]
    pub const CURAND_RNG_PSEUDO_XORWOW: curandRngType = curandRngType(101);
}
impl curandRngType {
    #[doc = "< MRG32k3a pseudorandom generator"]
    pub const CURAND_RNG_PSEUDO_MRG32K3A: curandRngType = curandRngType(121);
}
impl curandRngType {
    #[doc = "< Mersenne Twister MTGP32 pseudorandom generator"]
    pub const CURAND_RNG_PSEUDO_MTGP32: curandRngType = curandRngType(141);
}
impl curandRngType {
    #[doc = "< Mersenne Twister MT19937 pseudorandom generator"]
    pub const CURAND_RNG_PSEUDO_MT19937: curandRngType = curandRngType(142);
}
impl curandRngType {
    #[doc = "< PHILOX-4x32-10 pseudorandom generator"]
    pub const CURAND_RNG_PSEUDO_PHILOX4_32_10: curandRngType = curandRngType(161);
}
impl curandRngType {
    #[doc = "< Default quasirandom generator"]
    pub const CURAND_RNG_QUASI_DEFAULT: curandRngType = curandRngType(200);
}
impl curandRngType {
    #[doc = "< Sobol32 quasirandom generator"]
    pub const CURAND_RNG_QUASI_SOBOL32: curandRngType = curandRngType(201);
}
impl curandRngType {
    #[doc = "< Scrambled Sobol32 quasirandom generator"]
    pub const CURAND_RNG_QUASI_SCRAMBLED_SOBOL32: curandRngType = curandRngType(202);
}
impl curandRngType {
    #[doc = "< Sobol64 quasirandom generator"]
    pub const CURAND_RNG_QUASI_SOBOL64: curandRngType = curandRngType(203);
}
impl curandRngType {
    #[doc = "< Scrambled Sobol64 quasirandom generator"]
    pub const CURAND_RNG_QUASI_SCRAMBLED_SOBOL64: curandRngType = curandRngType(204);
}
#[repr(transparent)]
#[doc = " CURAND generator types"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct curandRngType(pub ::std::os::raw::c_uint);
#[doc = " \\cond UNHIDE_TYPEDEFS"]
pub use self::curandRngType as curandRngType_t;
impl curandOrdering {
    #[doc = "< Best ordering for pseudorandom results"]
    pub const CURAND_ORDERING_PSEUDO_BEST: curandOrdering = curandOrdering(100);
}
impl curandOrdering {
    #[doc = "< Specific default thread sequence for pseudorandom results, same as CURAND_ORDERING_PSEUDO_BEST"]
    pub const CURAND_ORDERING_PSEUDO_DEFAULT: curandOrdering = curandOrdering(101);
}
impl curandOrdering {
    #[doc = "< Specific seeding pattern for fast lower quality pseudorandom results"]
    pub const CURAND_ORDERING_PSEUDO_SEEDED: curandOrdering = curandOrdering(102);
}
impl curandOrdering {
    #[doc = "< Specific legacy sequence for pseudorandom results, guaranteed to remain the same for all cuRAND release"]
    pub const CURAND_ORDERING_PSEUDO_LEGACY: curandOrdering = curandOrdering(103);
}
impl curandOrdering {
    #[doc = "< Specific ordering adjusted to the device it is being executed on, provides the best performance"]
    pub const CURAND_ORDERING_PSEUDO_DYNAMIC: curandOrdering = curandOrdering(104);
}
impl curandOrdering {
    #[doc = "< Specific n-dimensional ordering for quasirandom results"]
    pub const CURAND_ORDERING_QUASI_DEFAULT: curandOrdering = curandOrdering(201);
}
#[repr(transparent)]
#[doc = " CURAND ordering of results in memory"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct curandOrdering(pub ::std::os::raw::c_uint);
#[doc = " \\cond UNHIDE_TYPEDEFS"]
pub use self::curandOrdering as curandOrdering_t;
impl curandDirectionVectorSet {
    #[doc = "< Specific set of 32-bit direction vectors generated from polynomials recommended by S. Joe and F. Y. Kuo, for up to 20,000 dimensions"]
    pub const CURAND_DIRECTION_VECTORS_32_JOEKUO6: curandDirectionVectorSet =
        curandDirectionVectorSet(101);
}
impl curandDirectionVectorSet {
    #[doc = "< Specific set of 32-bit direction vectors generated from polynomials recommended by S. Joe and F. Y. Kuo, for up to 20,000 dimensions, and scrambled"]
    pub const CURAND_SCRAMBLED_DIRECTION_VECTORS_32_JOEKUO6: curandDirectionVectorSet =
        curandDirectionVectorSet(102);
}
impl curandDirectionVectorSet {
    #[doc = "< Specific set of 64-bit direction vectors generated from polynomials recommended by S. Joe and F. Y. Kuo, for up to 20,000 dimensions"]
    pub const CURAND_DIRECTION_VECTORS_64_JOEKUO6: curandDirectionVectorSet =
        curandDirectionVectorSet(103);
}
impl curandDirectionVectorSet {
    #[doc = "< Specific set of 64-bit direction vectors generated from polynomials recommended by S. Joe and F. Y. Kuo, for up to 20,000 dimensions, and scrambled"]
    pub const CURAND_SCRAMBLED_DIRECTION_VECTORS_64_JOEKUO6: curandDirectionVectorSet =
        curandDirectionVectorSet(104);
}
#[repr(transparent)]
#[doc = " CURAND choice of direction vector set"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct curandDirectionVectorSet(pub ::std::os::raw::c_uint);
#[doc = " \\cond UNHIDE_TYPEDEFS"]
pub use self::curandDirectionVectorSet as curandDirectionVectorSet_t;
#[doc = " CURAND array of 32-bit direction vectors\n/\n/** \\cond UNHIDE_TYPEDEFS"]
pub type curandDirectionVectors32_t = [::std::os::raw::c_uint; 32usize];
#[doc = " CURAND array of 64-bit direction vectors\n/\n/** \\cond UNHIDE_TYPEDEFS"]
pub type curandDirectionVectors64_t = [::std::os::raw::c_ulonglong; 64usize];
#[doc = " CURAND generator (opaque)"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct curandGenerator_st {
    _unused: [u8; 0],
}
#[doc = " CURAND generator\n/\n/** \\cond UNHIDE_TYPEDEFS"]
pub type curandGenerator_t = *mut curandGenerator_st;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct curandDiscreteDistribution_st {
    _unused: [u8; 0],
}
pub type curandDiscreteDistribution_t = *mut curandDiscreteDistribution_st;
impl curandMethod {
    pub const CURAND_CHOOSE_BEST: curandMethod = curandMethod(0);
}
impl curandMethod {
    pub const CURAND_ITR: curandMethod = curandMethod(1);
}
impl curandMethod {
    pub const CURAND_KNUTH: curandMethod = curandMethod(2);
}
impl curandMethod {
    pub const CURAND_HITR: curandMethod = curandMethod(3);
}
impl curandMethod {
    pub const CURAND_M1: curandMethod = curandMethod(4);
}
impl curandMethod {
    pub const CURAND_M2: curandMethod = curandMethod(5);
}
impl curandMethod {
    pub const CURAND_BINARY_SEARCH: curandMethod = curandMethod(6);
}
impl curandMethod {
    pub const CURAND_DISCRETE_GAUSS: curandMethod = curandMethod(7);
}
impl curandMethod {
    pub const CURAND_REJECTION: curandMethod = curandMethod(8);
}
impl curandMethod {
    pub const CURAND_DEVICE_API: curandMethod = curandMethod(9);
}
impl curandMethod {
    pub const CURAND_FAST_REJECTION: curandMethod = curandMethod(10);
}
impl curandMethod {
    pub const CURAND_3RD: curandMethod = curandMethod(11);
}
impl curandMethod {
    pub const CURAND_DEFINITION: curandMethod = curandMethod(12);
}
impl curandMethod {
    pub const CURAND_POISSON: curandMethod = curandMethod(13);
}
#[repr(transparent)]
#[doc = " \\cond UNHIDE_ENUMS"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct curandMethod(pub ::std::os::raw::c_uint);
#[doc = " \\cond UNHIDE_ENUMS"]
pub use self::curandMethod as curandMethod_t;

#[doc = " \\brief Create new random number generator.\n\n Creates a new random number generator of type \\p rng_type\n and returns it in \\p *generator.\n\n Legal values for \\p rng_type are:\n - CURAND_RNG_PSEUDO_DEFAULT\n - CURAND_RNG_PSEUDO_XORWOW\n - CURAND_RNG_PSEUDO_MRG32K3A\n - CURAND_RNG_PSEUDO_MTGP32\n - CURAND_RNG_PSEUDO_MT19937\n - CURAND_RNG_PSEUDO_PHILOX4_32_10\n - CURAND_RNG_QUASI_DEFAULT\n - CURAND_RNG_QUASI_SOBOL32\n - CURAND_RNG_QUASI_SCRAMBLED_SOBOL32\n - CURAND_RNG_QUASI_SOBOL64\n - CURAND_RNG_QUASI_SCRAMBLED_SOBOL64\n\n When \\p rng_type is CURAND_RNG_PSEUDO_DEFAULT, the type chosen\n is CURAND_RNG_PSEUDO_XORWOW.  \\n\n When \\p rng_type is CURAND_RNG_QUASI_DEFAULT,\n the type chosen is CURAND_RNG_QUASI_SOBOL32.\n\n The default values for \\p rng_type = CURAND_RNG_PSEUDO_XORWOW are:\n - \\p seed = 0\n - \\p offset = 0\n - \\p ordering = CURAND_ORDERING_PSEUDO_DEFAULT\n\n The default values for \\p rng_type = CURAND_RNG_PSEUDO_MRG32K3A are:\n - \\p seed = 0\n - \\p offset = 0\n - \\p ordering = CURAND_ORDERING_PSEUDO_DEFAULT\n\n The default values for \\p rng_type = CURAND_RNG_PSEUDO_MTGP32 are:\n - \\p seed = 0\n - \\p offset = 0\n - \\p ordering = CURAND_ORDERING_PSEUDO_DEFAULT\n\n The default values for \\p rng_type = CURAND_RNG_PSEUDO_MT19937 are:\n - \\p seed = 0\n - \\p offset = 0\n - \\p ordering = CURAND_ORDERING_PSEUDO_DEFAULT\n\n * The default values for \\p rng_type = CURAND_RNG_PSEUDO_PHILOX4_32_10 are:\n - \\p seed = 0\n - \\p offset = 0\n - \\p ordering = CURAND_ORDERING_PSEUDO_DEFAULT\n\n The default values for \\p rng_type = CURAND_RNG_QUASI_SOBOL32 are:\n - \\p dimensions = 1\n - \\p offset = 0\n - \\p ordering = CURAND_ORDERING_QUASI_DEFAULT\n\n The default values for \\p rng_type = CURAND_RNG_QUASI_SOBOL64 are:\n - \\p dimensions = 1\n - \\p offset = 0\n - \\p ordering = CURAND_ORDERING_QUASI_DEFAULT\n\n The default values for \\p rng_type = CURAND_RNG_QUASI_SCRAMBBLED_SOBOL32 are:\n - \\p dimensions = 1\n - \\p offset = 0\n - \\p ordering = CURAND_ORDERING_QUASI_DEFAULT\n\n The default values for \\p rng_type = CURAND_RNG_QUASI_SCRAMBLED_SOBOL64 are:\n - \\p dimensions = 1\n - \\p offset = 0\n - \\p ordering = CURAND_ORDERING_QUASI_DEFAULT\n\n \\param generator - Pointer to generator\n \\param rng_type - Type of generator to create\n\n \\return\n - CURAND_STATUS_ALLOCATION_FAILED, if memory could not be allocated \\n\n - CURAND_STATUS_INITIALIZATION_FAILED if there was a problem setting up the GPU \\n\n - CURAND_STATUS_VERSION_MISMATCH if the header file version does not match the\n   dynamically linked library version \\n\n - CURAND_STATUS_TYPE_ERROR if the value for \\p rng_type is invalid \\n\n - CURAND_STATUS_SUCCESS if generator was created successfully \\n\n"]
#[no_mangle]
pub unsafe extern "system" fn curandCreateGenerator(
    generator: *mut curandGenerator_t,
    rng_type: curandRngType_t,
) -> curandStatus_t {
    crate::create_generator(generator, rng_type)
}

#[doc = " \\brief Create new host CPU random number generator.\n\n Creates a new host CPU random number generator of type \\p rng_type\n and returns it in \\p *generator.\n\n Legal values for \\p rng_type are:\n - CURAND_RNG_PSEUDO_DEFAULT\n - CURAND_RNG_PSEUDO_XORWOW\n - CURAND_RNG_PSEUDO_MRG32K3A\n - CURAND_RNG_PSEUDO_MTGP32\n - CURAND_RNG_PSEUDO_MT19937\n - CURAND_RNG_PSEUDO_PHILOX4_32_10\n - CURAND_RNG_QUASI_DEFAULT\n - CURAND_RNG_QUASI_SOBOL32\n\n When \\p rng_type is CURAND_RNG_PSEUDO_DEFAULT, the type chosen\n is CURAND_RNG_PSEUDO_XORWOW.  \\n\n When \\p rng_type is CURAND_RNG_QUASI_DEFAULT,\n the type chosen is CURAND_RNG_QUASI_SOBOL32.\n\n The default values for \\p rng_type = CURAND_RNG_PSEUDO_XORWOW are:\n - \\p seed = 0\n - \\p offset = 0\n - \\p ordering = CURAND_ORDERING_PSEUDO_DEFAULT\n\n The default values for \\p rng_type = CURAND_RNG_PSEUDO_MRG32K3A are:\n - \\p seed = 0\n - \\p offset = 0\n - \\p ordering = CURAND_ORDERING_PSEUDO_DEFAULT\n\n The default values for \\p rng_type = CURAND_RNG_PSEUDO_MTGP32 are:\n - \\p seed = 0\n - \\p offset = 0\n - \\p ordering = CURAND_ORDERING_PSEUDO_DEFAULT\n\n The default values for \\p rng_type = CURAND_RNG_PSEUDO_MT19937 are:\n - \\p seed = 0\n - \\p offset = 0\n - \\p ordering = CURAND_ORDERING_PSEUDO_DEFAULT\n\n * The default values for \\p rng_type = CURAND_RNG_PSEUDO_PHILOX4_32_10 are:\n - \\p seed = 0\n - \\p offset = 0\n - \\p ordering = CURAND_ORDERING_PSEUDO_DEFAULT\n\n The default values for \\p rng_type = CURAND_RNG_QUASI_SOBOL32 are:\n - \\p dimensions = 1\n - \\p offset = 0\n - \\p ordering = CURAND_ORDERING_QUASI_DEFAULT\n\n The default values for \\p rng_type = CURAND_RNG_QUASI_SOBOL64 are:\n - \\p dimensions = 1\n - \\p offset = 0\n - \\p ordering = CURAND_ORDERING_QUASI_DEFAULT\n\n The default values for \\p rng_type = CURAND_RNG_QUASI_SCRAMBLED_SOBOL32 are:\n - \\p dimensions = 1\n - \\p offset = 0\n - \\p ordering = CURAND_ORDERING_QUASI_DEFAULT\n\n The default values for \\p rng_type = CURAND_RNG_QUASI_SCRAMBLED_SOBOL64 are:\n - \\p dimensions = 1\n - \\p offset = 0\n - \\p ordering = CURAND_ORDERING_QUASI_DEFAULT\n\n \\param generator - Pointer to generator\n \\param rng_type - Type of generator to create\n\n \\return\n - CURAND_STATUS_ALLOCATION_FAILED if memory could not be allocated \\n\n - CURAND_STATUS_INITIALIZATION_FAILED if there was a problem setting up the GPU \\n\n - CURAND_STATUS_VERSION_MISMATCH if the header file version does not match the\n   dynamically linked library version \\n\n - CURAND_STATUS_TYPE_ERROR if the value for \\p rng_type is invalid \\n\n - CURAND_STATUS_SUCCESS if generator was created successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandCreateGeneratorHost(
    generator: *mut curandGenerator_t,
    rng_type: curandRngType_t,
) -> curandStatus_t {
    crate::create_generator_host(generator, rng_type)
}

#[doc = " \\brief Destroy an existing generator.\n\n Destroy an existing generator and free all memory associated with its state.\n\n \\param generator - Generator to destroy\n\n \\return\n - CURAND_STATUS_NOT_INITIALIZED if the generator was never created \\n\n - CURAND_STATUS_SUCCESS if generator was destroyed successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandDestroyGenerator(
    generator: curandGenerator_t,
) -> curandStatus_t {
    crate::destroy_generator(generator)
}

#[doc = " \\brief Return the version number of the library.\n\n Return in \\p *version the version number of the dynamically linked CURAND\n library.  The format is the same as CUDART_VERSION from the CUDA Runtime.\n The only supported configuration is CURAND version equal to CUDA Runtime\n version.\n\n \\param version - CURAND library version\n\n \\return\n - CURAND_STATUS_SUCCESS if the version number was successfully returned \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandGetVersion(
    version: *mut ::std::os::raw::c_int,
) -> curandStatus_t {
    crate::get_version(version)
}

#[doc = " \\brief Return the value of the curand property.\n\n Return in \\p *value the number for the property described by \\p type of the\n dynamically linked CURAND library.\n\n \\param type - CUDA library property\n \\param value - integer value for the requested property\n\n \\return\n - CURAND_STATUS_SUCCESS if the property value was successfully returned \\n\n - CURAND_STATUS_OUT_OF_RANGE if the property type is not recognized \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandGetProperty(
    type_: libraryPropertyType,
    value: *mut ::std::os::raw::c_int,
) -> curandStatus_t {
    curandStatus_t::CURAND_STATUS_INTERNAL_ERROR
}

#[doc = " \\brief Set the current stream for CURAND kernel launches.\n\n Set the current stream for CURAND kernel launches.  All library functions\n will use this stream until set again.\n\n \\param generator - Generator to modify\n \\param stream - Stream to use or ::NULL for null stream\n\n \\return\n - CURAND_STATUS_NOT_INITIALIZED if the generator was never created \\n\n - CURAND_STATUS_SUCCESS if stream was set successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandSetStream(
    generator: curandGenerator_t,
    stream: cudaStream_t,
) -> curandStatus_t {
    crate::set_stream(generator, stream)
}

#[doc = " \\brief Set the seed value of the pseudo-random number generator.\n\n Set the seed value of the pseudorandom number generator.\n All values of seed are valid.  Different seeds will produce different sequences.\n Different seeds will often not be statistically correlated with each other,\n but some pairs of seed values may generate sequences which are statistically correlated.\n\n \\param generator - Generator to modify\n \\param seed - Seed value\n\n \\return\n - CURAND_STATUS_NOT_INITIALIZED if the generator was never created \\n\n - CURAND_STATUS_TYPE_ERROR if the generator is not a pseudorandom number generator \\n\n - CURAND_STATUS_SUCCESS if generator seed was set successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandSetPseudoRandomGeneratorSeed(
    generator: curandGenerator_t,
    seed: ::std::os::raw::c_ulonglong,
) -> curandStatus_t {
    crate::set_pseudo_random_generator_seed(generator, seed)
}

#[doc = " \\brief Set the absolute offset of the pseudo or quasirandom number generator.\n\n Set the absolute offset of the pseudo or quasirandom number generator.\n\n All values of offset are valid.  The offset position is absolute, not\n relative to the current position in the sequence.\n\n \\param generator - Generator to modify\n \\param offset - Absolute offset position\n\n \\return\n - CURAND_STATUS_NOT_INITIALIZED if the generator was never created \\n\n - CURAND_STATUS_SUCCESS if generator offset was set successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandSetGeneratorOffset(
    generator: curandGenerator_t,
    offset: ::std::os::raw::c_ulonglong,
) -> curandStatus_t {
    crate::set_generator_offset(generator, offset)
}

#[doc = " \\brief Set the ordering of results of the pseudo or quasirandom number generator.\n\n Set the ordering of results of the pseudo or quasirandom number generator.\n\n Legal values of \\p order for pseudorandom generators are:\n - CURAND_ORDERING_PSEUDO_DEFAULT\n - CURAND_ORDERING_PSEUDO_BEST\n - CURAND_ORDERING_PSEUDO_SEEDED\n - CURAND_ORDERING_PSEUDO_LEGACY\n\n Legal values of \\p order for quasirandom generators are:\n - CURAND_ORDERING_QUASI_DEFAULT\n\n \\param generator - Generator to modify\n \\param order - Ordering of results\n\n \\return\n - CURAND_STATUS_NOT_INITIALIZED if the generator was never created \\n\n - CURAND_STATUS_OUT_OF_RANGE if the ordering is not valid \\n\n - CURAND_STATUS_SUCCESS if generator ordering was set successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandSetGeneratorOrdering(
    generator: curandGenerator_t,
    order: curandOrdering_t,
) -> curandStatus_t {
    curandStatus_t::CURAND_STATUS_INTERNAL_ERROR
}

#[doc = " \\brief Set the number of dimensions.\n\n Set the number of dimensions to be generated by the quasirandom number\n generator.\n\n Legal values for \\p num_dimensions are 1 to 20000.\n\n \\param generator - Generator to modify\n \\param num_dimensions - Number of dimensions\n\n \\return\n - CURAND_STATUS_NOT_INITIALIZED if the generator was never created \\n\n - CURAND_STATUS_OUT_OF_RANGE if num_dimensions is not valid \\n\n - CURAND_STATUS_TYPE_ERROR if the generator is not a quasirandom number generator \\n\n - CURAND_STATUS_SUCCESS if generator ordering was set successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandSetQuasiRandomGeneratorDimensions(
    generator: curandGenerator_t,
    num_dimensions: ::std::os::raw::c_uint,
) -> curandStatus_t {
    crate::set_quasi_random_generator_dimensions(generator, num_dimensions)
}

#[doc = " \\brief Generate 32-bit pseudo or quasirandom numbers.\n\n Use \\p generator to generate \\p num 32-bit results into the device memory at\n \\p outputPtr.  The device memory must have been previously allocated and be\n large enough to hold all the results.  Launches are done with the stream\n set using ::curandSetStream(), or the null stream if no stream has been set.\n\n Results are 32-bit values with every bit random.\n\n \\param generator - Generator to use\n \\param outputPtr - Pointer to device memory to store CUDA-generated results, or\n                 Pointer to host memory to store CPU-generated results\n \\param num - Number of random 32-bit values to generate\n\n \\return\n - CURAND_STATUS_ALLOCATION_FAILED if memory could not be allocated \\n\n - CURAND_STATUS_NOT_INITIALIZED if the generator was never created \\n\n - CURAND_STATUS_PREEXISTING_FAILURE if there was an existing error from\n     a previous kernel launch \\n\n - CURAND_STATUS_LENGTH_NOT_MULTIPLE if the number of output samples is\n    not a multiple of the quasirandom dimension \\n\n - CURAND_STATUS_LAUNCH_FAILURE if the kernel launch failed for any reason \\n\n - CURAND_STATUS_TYPE_ERROR if the generator is a 64 bit quasirandom generator.\n (use ::curandGenerateLongLong() with 64 bit quasirandom generators)\n - CURAND_STATUS_SUCCESS if the results were generated successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandGenerate(
    generator: curandGenerator_t,
    outputPtr: *mut ::std::os::raw::c_uint,
    num: usize,
) -> curandStatus_t {
    crate::generate(generator, outputPtr, num)
}

#[doc = " \\brief Generate 64-bit quasirandom numbers.\n\n Use \\p generator to generate \\p num 64-bit results into the device memory at\n \\p outputPtr.  The device memory must have been previously allocated and be\n large enough to hold all the results.  Launches are done with the stream\n set using ::curandSetStream(), or the null stream if no stream has been set.\n\n Results are 64-bit values with every bit random.\n\n \\param generator - Generator to use\n \\param outputPtr - Pointer to device memory to store CUDA-generated results, or\n                 Pointer to host memory to store CPU-generated results\n \\param num - Number of random 64-bit values to generate\n\n \\return\n - CURAND_STATUS_NOT_INITIALIZED if the generator was never created \\n\n - CURAND_STATUS_PREEXISTING_FAILURE if there was an existing error from\n     a previous kernel launch \\n\n - CURAND_STATUS_LENGTH_NOT_MULTIPLE if the number of output samples is\n    not a multiple of the quasirandom dimension \\n\n - CURAND_STATUS_LAUNCH_FAILURE if the kernel launch failed for any reason \\n\n - CURAND_STATUS_TYPE_ERROR if the generator is not a 64 bit quasirandom generator\\n\n - CURAND_STATUS_SUCCESS if the results were generated successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandGenerateLongLong(
    generator: curandGenerator_t,
    outputPtr: *mut ::std::os::raw::c_ulonglong,
    num: usize,
) -> curandStatus_t {
    curandStatus_t::CURAND_STATUS_INTERNAL_ERROR
}

#[doc = " \\brief Generate uniformly distributed floats.\n\n Use \\p generator to generate \\p num float results into the device memory at\n \\p outputPtr.  The device memory must have been previously allocated and be\n large enough to hold all the results.  Launches are done with the stream\n set using ::curandSetStream(), or the null stream if no stream has been set.\n\n Results are 32-bit floating point values between \\p 0.0f and \\p 1.0f,\n excluding \\p 0.0f and including \\p 1.0f.\n\n \\param generator - Generator to use\n \\param outputPtr - Pointer to device memory to store CUDA-generated results, or\n                 Pointer to host memory to store CPU-generated results\n \\param num - Number of floats to generate\n\n \\return\n - CURAND_STATUS_ALLOCATION_FAILED if memory could not be allocated \\n\n - CURAND_STATUS_NOT_INITIALIZED if the generator was never created \\n\n - CURAND_STATUS_PREEXISTING_FAILURE if there was an existing error from\n    a previous kernel launch \\n\n - CURAND_STATUS_LAUNCH_FAILURE if the kernel launch failed for any reason \\n\n - CURAND_STATUS_LENGTH_NOT_MULTIPLE if the number of output samples is\n    not a multiple of the quasirandom dimension \\n\n - CURAND_STATUS_SUCCESS if the results were generated successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandGenerateUniform(
    generator: curandGenerator_t,
    outputPtr: *mut f32,
    num: usize,
) -> curandStatus_t {
    crate::generate_uniform(generator, outputPtr, num)
}

#[doc = " \\brief Generate uniformly distributed doubles.\n\n Use \\p generator to generate \\p num double results into the device memory at\n \\p outputPtr.  The device memory must have been previously allocated and be\n large enough to hold all the results.  Launches are done with the stream\n set using ::curandSetStream(), or the null stream if no stream has been set.\n\n Results are 64-bit double precision floating point values between\n \\p 0.0 and \\p 1.0, excluding \\p 0.0 and including \\p 1.0.\n\n \\param generator - Generator to use\n \\param outputPtr - Pointer to device memory to store CUDA-generated results, or\n                 Pointer to host memory to store CPU-generated results\n \\param num - Number of doubles to generate\n\n \\return\n - CURAND_STATUS_ALLOCATION_FAILED if memory could not be allocated \\n\n - CURAND_STATUS_NOT_INITIALIZED if the generator was never created \\n\n - CURAND_STATUS_PREEXISTING_FAILURE if there was an existing error from\n    a previous kernel launch \\n\n - CURAND_STATUS_LAUNCH_FAILURE if the kernel launch failed for any reason \\n\n - CURAND_STATUS_LENGTH_NOT_MULTIPLE if the number of output samples is\n    not a multiple of the quasirandom dimension \\n\n - CURAND_STATUS_DOUBLE_PRECISION_REQUIRED if the GPU does not support double precision \\n\n - CURAND_STATUS_SUCCESS if the results were generated successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandGenerateUniformDouble(
    generator: curandGenerator_t,
    outputPtr: *mut f64,
    num: usize,
) -> curandStatus_t {
    crate::generate_uniform_double(generator, outputPtr, num)
}

#[doc = " \\brief Generate normally distributed doubles.\n\n Use \\p generator to generate \\p n float results into the device memory at\n \\p outputPtr.  The device memory must have been previously allocated and be\n large enough to hold all the results.  Launches are done with the stream\n set using ::curandSetStream(), or the null stream if no stream has been set.\n\n Results are 32-bit floating point values with mean \\p mean and standard\n deviation \\p stddev.\n\n Normally distributed results are generated from pseudorandom generators\n with a Box-Muller transform, and so require \\p n to be even.\n Quasirandom generators use an inverse cumulative distribution\n function to preserve dimensionality.\n\n There may be slight numerical differences between results generated\n on the GPU with generators created with ::curandCreateGenerator()\n and results calculated on the CPU with generators created with\n ::curandCreateGeneratorHost().  These differences arise because of\n differences in results for transcendental functions.  In addition,\n future versions of CURAND may use newer versions of the CUDA math\n library, so different versions of CURAND may give slightly different\n numerical values.\n\n \\param generator - Generator to use\n \\param outputPtr - Pointer to device memory to store CUDA-generated results, or\n                 Pointer to host memory to store CPU-generated results\n \\param n - Number of floats to generate\n \\param mean - Mean of normal distribution\n \\param stddev - Standard deviation of normal distribution\n\n \\return\n - CURAND_STATUS_ALLOCATION_FAILED if memory could not be allocated \\n\n - CURAND_STATUS_NOT_INITIALIZED if the generator was never created \\n\n - CURAND_STATUS_PREEXISTING_FAILURE if there was an existing error from\n    a previous kernel launch \\n\n - CURAND_STATUS_LAUNCH_FAILURE if the kernel launch failed for any reason \\n\n - CURAND_STATUS_LENGTH_NOT_MULTIPLE if the number of output samples is\n    not a multiple of the quasirandom dimension, or is not a multiple\n    of two for pseudorandom generators \\n\n - CURAND_STATUS_SUCCESS if the results were generated successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandGenerateNormal(
    generator: curandGenerator_t,
    outputPtr: *mut f32,
    n: usize,
    mean: f32,
    stddev: f32,
) -> curandStatus_t {
    crate::generate_normal(generator, outputPtr, n, mean, stddev)
}

#[doc = " \\brief Generate normally distributed doubles.\n\n Use \\p generator to generate \\p n double results into the device memory at\n \\p outputPtr.  The device memory must have been previously allocated and be\n large enough to hold all the results.  Launches are done with the stream\n set using ::curandSetStream(), or the null stream if no stream has been set.\n\n Results are 64-bit floating point values with mean \\p mean and standard\n deviation \\p stddev.\n\n Normally distributed results are generated from pseudorandom generators\n with a Box-Muller transform, and so require \\p n to be even.\n Quasirandom generators use an inverse cumulative distribution\n function to preserve dimensionality.\n\n There may be slight numerical differences between results generated\n on the GPU with generators created with ::curandCreateGenerator()\n and results calculated on the CPU with generators created with\n ::curandCreateGeneratorHost().  These differences arise because of\n differences in results for transcendental functions.  In addition,\n future versions of CURAND may use newer versions of the CUDA math\n library, so different versions of CURAND may give slightly different\n numerical values.\n\n \\param generator - Generator to use\n \\param outputPtr - Pointer to device memory to store CUDA-generated results, or\n                 Pointer to host memory to store CPU-generated results\n \\param n - Number of doubles to generate\n \\param mean - Mean of normal distribution\n \\param stddev - Standard deviation of normal distribution\n\n \\return\n - CURAND_STATUS_ALLOCATION_FAILED if memory could not be allocated \\n\n - CURAND_STATUS_NOT_INITIALIZED if the generator was never created \\n\n - CURAND_STATUS_PREEXISTING_FAILURE if there was an existing error from\n    a previous kernel launch \\n\n - CURAND_STATUS_LAUNCH_FAILURE if the kernel launch failed for any reason \\n\n - CURAND_STATUS_LENGTH_NOT_MULTIPLE if the number of output samples is\n    not a multiple of the quasirandom dimension, or is not a multiple\n    of two for pseudorandom generators \\n\n - CURAND_STATUS_DOUBLE_PRECISION_REQUIRED if the GPU does not support double precision \\n\n - CURAND_STATUS_SUCCESS if the results were generated successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandGenerateNormalDouble(
    generator: curandGenerator_t,
    outputPtr: *mut f64,
    n: usize,
    mean: f64,
    stddev: f64,
) -> curandStatus_t {
    crate::generate_normal_double(generator, outputPtr, n, mean, stddev)
}

#[doc = " \\brief Generate log-normally distributed floats.\n\n Use \\p generator to generate \\p n float results into the device memory at\n \\p outputPtr.  The device memory must have been previously allocated and be\n large enough to hold all the results.  Launches are done with the stream\n set using ::curandSetStream(), or the null stream if no stream has been set.\n\n Results are 32-bit floating point values with log-normal distribution based on\n an associated normal distribution with mean \\p mean and standard deviation \\p stddev.\n\n Normally distributed results are generated from pseudorandom generators\n with a Box-Muller transform, and so require \\p n to be even.\n Quasirandom generators use an inverse cumulative distribution\n function to preserve dimensionality.\n The normally distributed results are transformed into log-normal distribution.\n\n There may be slight numerical differences between results generated\n on the GPU with generators created with ::curandCreateGenerator()\n and results calculated on the CPU with generators created with\n ::curandCreateGeneratorHost().  These differences arise because of\n differences in results for transcendental functions.  In addition,\n future versions of CURAND may use newer versions of the CUDA math\n library, so different versions of CURAND may give slightly different\n numerical values.\n\n \\param generator - Generator to use\n \\param outputPtr - Pointer to device memory to store CUDA-generated results, or\n                 Pointer to host memory to store CPU-generated results\n \\param n - Number of floats to generate\n \\param mean - Mean of associated normal distribution\n \\param stddev - Standard deviation of associated normal distribution\n\n \\return\n - CURAND_STATUS_ALLOCATION_FAILED if memory could not be allocated \\n\n - CURAND_STATUS_NOT_INITIALIZED if the generator was never created \\n\n - CURAND_STATUS_PREEXISTING_FAILURE if there was an existing error from\n    a previous kernel launch \\n\n - CURAND_STATUS_LAUNCH_FAILURE if the kernel launch failed for any reason \\n\n - CURAND_STATUS_LENGTH_NOT_MULTIPLE if the number of output samples is\n    not a multiple of the quasirandom dimension, or is not a multiple\n    of two for pseudorandom generators \\n\n - CURAND_STATUS_SUCCESS if the results were generated successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandGenerateLogNormal(
    generator: curandGenerator_t,
    outputPtr: *mut f32,
    n: usize,
    mean: f32,
    stddev: f32,
) -> curandStatus_t {
    crate::generate_log_normal(generator, outputPtr, n, mean, stddev)
}

#[doc = " \\brief Generate log-normally distributed doubles.\n\n Use \\p generator to generate \\p n double results into the device memory at\n \\p outputPtr.  The device memory must have been previously allocated and be\n large enough to hold all the results.  Launches are done with the stream\n set using ::curandSetStream(), or the null stream if no stream has been set.\n\n Results are 64-bit floating point values with log-normal distribution based on\n an associated normal distribution with mean \\p mean and standard deviation \\p stddev.\n\n Normally distributed results are generated from pseudorandom generators\n with a Box-Muller transform, and so require \\p n to be even.\n Quasirandom generators use an inverse cumulative distribution\n function to preserve dimensionality.\n The normally distributed results are transformed into log-normal distribution.\n\n There may be slight numerical differences between results generated\n on the GPU with generators created with ::curandCreateGenerator()\n and results calculated on the CPU with generators created with\n ::curandCreateGeneratorHost().  These differences arise because of\n differences in results for transcendental functions.  In addition,\n future versions of CURAND may use newer versions of the CUDA math\n library, so different versions of CURAND may give slightly different\n numerical values.\n\n \\param generator - Generator to use\n \\param outputPtr - Pointer to device memory to store CUDA-generated results, or\n                 Pointer to host memory to store CPU-generated results\n \\param n - Number of doubles to generate\n \\param mean - Mean of normal distribution\n \\param stddev - Standard deviation of normal distribution\n\n \\return\n - CURAND_STATUS_ALLOCATION_FAILED if memory could not be allocated \\n\n - CURAND_STATUS_NOT_INITIALIZED if the generator was never created \\n\n - CURAND_STATUS_PREEXISTING_FAILURE if there was an existing error from\n    a previous kernel launch \\n\n - CURAND_STATUS_LAUNCH_FAILURE if the kernel launch failed for any reason \\n\n - CURAND_STATUS_LENGTH_NOT_MULTIPLE if the number of output samples is\n    not a multiple of the quasirandom dimension, or is not a multiple\n    of two for pseudorandom generators \\n\n - CURAND_STATUS_DOUBLE_PRECISION_REQUIRED if the GPU does not support double precision \\n\n - CURAND_STATUS_SUCCESS if the results were generated successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandGenerateLogNormalDouble(
    generator: curandGenerator_t,
    outputPtr: *mut f64,
    n: usize,
    mean: f64,
    stddev: f64,
) -> curandStatus_t {
    crate::generate_log_normal_double(generator, outputPtr, n, mean, stddev)
}

#[doc = " \\brief Construct the histogram array for a Poisson distribution.\n\n Construct the histogram array for the Poisson distribution with lambda \\p lambda.\n For lambda greater than 2000, an approximation with a normal distribution is used.\n\n \\param lambda - lambda for the Poisson distribution\n\n\n \\param discrete_distribution - pointer to the histogram in device memory\n\n \\return\n - CURAND_STATUS_ALLOCATION_FAILED if memory could not be allocated \\n\n - CURAND_STATUS_DOUBLE_PRECISION_REQUIRED if the GPU does not support double precision \\n\n - CURAND_STATUS_INITIALIZATION_FAILED if there was a problem setting up the GPU \\n\n - CURAND_STATUS_NOT_INITIALIZED if the distribution pointer was null \\n\n - CURAND_STATUS_PREEXISTING_FAILURE if there was an existing error from\n    a previous kernel launch \\n\n - CURAND_STATUS_OUT_OF_RANGE if lambda is non-positive or greater than 400,000 \\n\n - CURAND_STATUS_SUCCESS if the histogram was generated successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandCreatePoissonDistribution(
    lambda: f64,
    discrete_distribution: *mut curandDiscreteDistribution_t,
) -> curandStatus_t {
    crate::create_poisson_distribution(lambda, discrete_distribution)
}

#[doc = " \\brief Destroy the histogram array for a discrete distribution (e.g. Poisson).\n\n Destroy the histogram array for a discrete distribution created by curandCreatePoissonDistribution.\n\n \\param discrete_distribution - pointer to device memory where the histogram is stored\n\n \\return\n - CURAND_STATUS_NOT_INITIALIZED if the histogram was never created \\n\n - CURAND_STATUS_SUCCESS if the histogram was destroyed successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandDestroyDistribution(
    discrete_distribution: curandDiscreteDistribution_t,
) -> curandStatus_t {
    crate::destroy_distribution(discrete_distribution)
}

#[doc = " \\brief Generate Poisson-distributed unsigned ints.\n\n Use \\p generator to generate \\p n unsigned int results into device memory at\n \\p outputPtr.  The device memory must have been previously allocated and must be\n large enough to hold all the results.  Launches are done with the stream\n set using ::curandSetStream(), or the null stream if no stream has been set.\n\n Results are 32-bit unsigned int point values with Poisson distribution, with lambda \\p lambda.\n\n \\param generator - Generator to use\n \\param outputPtr - Pointer to device memory to store CUDA-generated results, or\n                 Pointer to host memory to store CPU-generated results\n \\param n - Number of unsigned ints to generate\n \\param lambda - lambda for the Poisson distribution\n\n \\return\n - CURAND_STATUS_ALLOCATION_FAILED if memory could not be allocated \\n\n - CURAND_STATUS_NOT_INITIALIZED if the generator was never created \\n\n - CURAND_STATUS_PREEXISTING_FAILURE if there was an existing error from\n    a previous kernel launch \\n\n - CURAND_STATUS_LAUNCH_FAILURE if the kernel launch failed for any reason \\n\n - CURAND_STATUS_LENGTH_NOT_MULTIPLE if the number of output samples is\n    not a multiple of the quasirandom dimension\\n\n - CURAND_STATUS_DOUBLE_PRECISION_REQUIRED if the GPU or sm does not support double precision \\n\n - CURAND_STATUS_OUT_OF_RANGE if lambda is non-positive or greater than 400,000 \\n\n - CURAND_STATUS_SUCCESS if the results were generated successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandGeneratePoisson(
    generator: curandGenerator_t,
    outputPtr: *mut ::std::os::raw::c_uint,
    n: usize,
    lambda: f64,
) -> curandStatus_t {
    crate::generate_poisson(generator, outputPtr, n, lambda)
}

#[no_mangle]
pub unsafe extern "system" fn curandGenerateBinomial(
    generator: curandGenerator_t,
    outputPtr: *mut ::std::os::raw::c_uint,
    num: usize,
    n: ::std::os::raw::c_uint,
    p: f64,
) -> curandStatus_t {
    curandStatus_t::CURAND_STATUS_INTERNAL_ERROR
}

#[doc = " \\brief Setup starting states.\n\n Generate the starting state of the generator.  This function is\n automatically called by generation functions such as\n ::curandGenerate() and ::curandGenerateUniform().\n It can be called manually for performance testing reasons to separate\n timings for starting state generation and random number generation.\n\n \\param generator - Generator to update\n\n \\return\n - CURAND_STATUS_ALLOCATION_FAILED if memory could not be allocated \\n\n - CURAND_STATUS_NOT_INITIALIZED if the generator was never created \\n\n - CURAND_STATUS_PREEXISTING_FAILURE if there was an existing error from\n     a previous kernel launch \\n\n - CURAND_STATUS_LAUNCH_FAILURE if the kernel launch failed for any reason \\n\n - CURAND_STATUS_SUCCESS if the seeds were generated successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandGenerateSeeds(generator: curandGenerator_t) -> curandStatus_t {
    crate::generate_seeds(generator)
}

#[doc = " \\brief Get direction vectors for 32-bit quasirandom number generation.\n\n Get a pointer to an array of direction vectors that can be used\n for quasirandom number generation.  The resulting pointer will\n reference an array of direction vectors in host memory.\n\n The array contains vectors for many dimensions.  Each dimension\n has 32 vectors.  Each individual vector is an unsigned int.\n\n Legal values for \\p set are:\n - CURAND_DIRECTION_VECTORS_32_JOEKUO6 (20,000 dimensions)\n - CURAND_SCRAMBLED_DIRECTION_VECTORS_32_JOEKUO6 (20,000 dimensions)\n\n \\param vectors - Address of pointer in which to return direction vectors\n \\param set - Which set of direction vectors to use\n\n \\return\n - CURAND_STATUS_OUT_OF_RANGE if the choice of set is invalid \\n\n - CURAND_STATUS_SUCCESS if the pointer was set successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandGetDirectionVectors32(
    vectors: *mut *mut curandDirectionVectors32_t,
    set: curandDirectionVectorSet_t,
) -> curandStatus_t {
    crate::unsupported()
}

#[doc = " \\brief Get scramble constants for 32-bit scrambled Sobol' .\n\n Get a pointer to an array of scramble constants that can be used\n for quasirandom number generation.  The resulting pointer will\n reference an array of unsinged ints in host memory.\n\n The array contains constants for many dimensions.  Each dimension\n has a single unsigned int constant.\n\n \\param constants - Address of pointer in which to return scramble constants\n\n \\return\n - CURAND_STATUS_SUCCESS if the pointer was set successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandGetScrambleConstants32(
    constants: *mut *mut ::std::os::raw::c_uint,
) -> curandStatus_t {
    crate::unsupported()
}

#[doc = " \\brief Get direction vectors for 64-bit quasirandom number generation.\n\n Get a pointer to an array of direction vectors that can be used\n for quasirandom number generation.  The resulting pointer will\n reference an array of direction vectors in host memory.\n\n The array contains vectors for many dimensions.  Each dimension\n has 64 vectors.  Each individual vector is an unsigned long long.\n\n Legal values for \\p set are:\n - CURAND_DIRECTION_VECTORS_64_JOEKUO6 (20,000 dimensions)\n - CURAND_SCRAMBLED_DIRECTION_VECTORS_64_JOEKUO6 (20,000 dimensions)\n\n \\param vectors - Address of pointer in which to return direction vectors\n \\param set - Which set of direction vectors to use\n\n \\return\n - CURAND_STATUS_OUT_OF_RANGE if the choice of set is invalid \\n\n - CURAND_STATUS_SUCCESS if the pointer was set successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandGetDirectionVectors64(
    vectors: *mut *mut curandDirectionVectors64_t,
    set: curandDirectionVectorSet_t,
) -> curandStatus_t {
    crate::unsupported()
}

#[doc = " \\brief Get scramble constants for 64-bit scrambled Sobol' .\n\n Get a pointer to an array of scramble constants that can be used\n for quasirandom number generation.  The resulting pointer will\n reference an array of unsinged long longs in host memory.\n\n The array contains constants for many dimensions.  Each dimension\n has a single unsigned long long constant.\n\n \\param constants - Address of pointer in which to return scramble constants\n\n \\return\n - CURAND_STATUS_SUCCESS if the pointer was set successfully \\n"]
#[no_mangle]
pub unsafe extern "system" fn curandGetScrambleConstants64(
    constants: *mut *mut ::std::os::raw::c_ulonglong,
) -> curandStatus_t {
    crate::unsupported()
}
