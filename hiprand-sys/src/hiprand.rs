/* automatically generated by rust-bindgen 0.69.4 */

#[repr(C)]
#[derive(Copy, Clone)]
pub struct ihipStream_t {
    _unused: [u8; 0],
}
pub type hipStream_t = *mut ihipStream_t;
#[repr(C)]
pub struct __half {
    pub __x: ::std::os::raw::c_ushort,
}
#[doc = " \\cond HIPRAND_DOCS_TYPEDEFS\n hipRAND half type (derived from HIP)"]
pub type half = __half;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rocrand_discrete_distribution_st {
    pub size: ::std::os::raw::c_uint,
    pub offset: ::std::os::raw::c_uint,
    pub alias: *mut ::std::os::raw::c_uint,
    pub probability: *mut f64,
    pub cdf: *mut f64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rocrand_generator_base_type {
    _unused: [u8; 0],
}
pub type hiprandGenerator_st = rocrand_generator_base_type;
pub type hiprandDiscreteDistribution_st = rocrand_discrete_distribution_st;
#[doc = " \\cond HIPRAND_DOCS_TYPEDEFS\n \\brief hipRAND random number generator (opaque)"]
pub type hiprandGenerator_t = *mut hiprandGenerator_st;
#[doc = " \\cond HIPRAND_DOCS_TYPEDEFS\n \\brief hipRAND discrete distribution"]
pub type hiprandDiscreteDistribution_t = *mut hiprandDiscreteDistribution_st;
impl hiprandStatus {
    #[doc = "< Success"]
    pub const HIPRAND_STATUS_SUCCESS: hiprandStatus = hiprandStatus(0);
}
impl hiprandStatus {
    #[doc = "< Header file and linked library version do not match"]
    pub const HIPRAND_STATUS_VERSION_MISMATCH: hiprandStatus = hiprandStatus(100);
}
impl hiprandStatus {
    #[doc = "< Generator not created"]
    pub const HIPRAND_STATUS_NOT_INITIALIZED: hiprandStatus = hiprandStatus(101);
}
impl hiprandStatus {
    #[doc = "< Memory allocation failed"]
    pub const HIPRAND_STATUS_ALLOCATION_FAILED: hiprandStatus = hiprandStatus(102);
}
impl hiprandStatus {
    #[doc = "< Generator type is wrong"]
    pub const HIPRAND_STATUS_TYPE_ERROR: hiprandStatus = hiprandStatus(103);
}
impl hiprandStatus {
    #[doc = "< Argument out of range"]
    pub const HIPRAND_STATUS_OUT_OF_RANGE: hiprandStatus = hiprandStatus(104);
}
impl hiprandStatus {
    #[doc = "< Requested size is not a multiple of quasirandom generator's dimension,\n< or requested size is not even (see hiprandGenerateNormal()),\n< or pointer is misaligned (see hiprandGenerateNormal())"]
    pub const HIPRAND_STATUS_LENGTH_NOT_MULTIPLE: hiprandStatus = hiprandStatus(105);
}
impl hiprandStatus {
    #[doc = "< GPU does not have double precision"]
    pub const HIPRAND_STATUS_DOUBLE_PRECISION_REQUIRED: hiprandStatus = hiprandStatus(106);
}
impl hiprandStatus {
    #[doc = "< Kernel launch failure"]
    pub const HIPRAND_STATUS_LAUNCH_FAILURE: hiprandStatus = hiprandStatus(201);
}
impl hiprandStatus {
    #[doc = "< Preexisting failure on library entry"]
    pub const HIPRAND_STATUS_PREEXISTING_FAILURE: hiprandStatus = hiprandStatus(202);
}
impl hiprandStatus {
    #[doc = "< Initialization of HIP failed"]
    pub const HIPRAND_STATUS_INITIALIZATION_FAILED: hiprandStatus = hiprandStatus(203);
}
impl hiprandStatus {
    #[doc = "< Architecture mismatch, GPU does not support requested feature"]
    pub const HIPRAND_STATUS_ARCH_MISMATCH: hiprandStatus = hiprandStatus(204);
}
impl hiprandStatus {
    #[doc = "< Internal library error"]
    pub const HIPRAND_STATUS_INTERNAL_ERROR: hiprandStatus = hiprandStatus(999);
}
impl hiprandStatus {
    #[doc = "< Feature not implemented yet"]
    pub const HIPRAND_STATUS_NOT_IMPLEMENTED: hiprandStatus = hiprandStatus(1000);
}
#[repr(transparent)]
#[doc = " \\brief hipRAND function call status type"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprandStatus(pub ::std::os::raw::c_uint);
#[doc = " \\brief hipRAND function call status type"]
pub use self::hiprandStatus as hiprandStatus_t;
impl hiprandRngType {
    #[doc = " \\cond"]
    pub const HIPRAND_RNG_TEST: hiprandRngType = hiprandRngType(0);
}
impl hiprandRngType {
    #[doc = "< Default pseudorandom generator"]
    pub const HIPRAND_RNG_PSEUDO_DEFAULT: hiprandRngType = hiprandRngType(400);
}
impl hiprandRngType {
    #[doc = "< XORWOW pseudorandom generator"]
    pub const HIPRAND_RNG_PSEUDO_XORWOW: hiprandRngType = hiprandRngType(401);
}
impl hiprandRngType {
    #[doc = "< MRG32k3a pseudorandom generator"]
    pub const HIPRAND_RNG_PSEUDO_MRG32K3A: hiprandRngType = hiprandRngType(402);
}
impl hiprandRngType {
    #[doc = "< Mersenne Twister MTGP32 pseudorandom generator"]
    pub const HIPRAND_RNG_PSEUDO_MTGP32: hiprandRngType = hiprandRngType(403);
}
impl hiprandRngType {
    #[doc = "< Mersenne Twister 19937"]
    pub const HIPRAND_RNG_PSEUDO_MT19937: hiprandRngType = hiprandRngType(404);
}
impl hiprandRngType {
    #[doc = "< PHILOX_4x32 (10 rounds) pseudorandom generator"]
    pub const HIPRAND_RNG_PSEUDO_PHILOX4_32_10: hiprandRngType = hiprandRngType(405);
}
impl hiprandRngType {
    #[doc = "< Default quasirandom generator"]
    pub const HIPRAND_RNG_QUASI_DEFAULT: hiprandRngType = hiprandRngType(500);
}
impl hiprandRngType {
    #[doc = "< Sobol32 quasirandom generator"]
    pub const HIPRAND_RNG_QUASI_SOBOL32: hiprandRngType = hiprandRngType(501);
}
impl hiprandRngType {
    #[doc = "< Scrambled Sobol32 quasirandom generator"]
    pub const HIPRAND_RNG_QUASI_SCRAMBLED_SOBOL32: hiprandRngType = hiprandRngType(502);
}
impl hiprandRngType {
    #[doc = "< Sobol64 quasirandom generator"]
    pub const HIPRAND_RNG_QUASI_SOBOL64: hiprandRngType = hiprandRngType(503);
}
impl hiprandRngType {
    #[doc = "< Scrambled Sobol64 quasirandom generator"]
    pub const HIPRAND_RNG_QUASI_SCRAMBLED_SOBOL64: hiprandRngType = hiprandRngType(504);
}
#[repr(transparent)]
#[doc = " \\brief hipRAND generator type"]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct hiprandRngType(pub ::std::os::raw::c_uint);
#[doc = " \\brief hipRAND generator type"]
pub use self::hiprandRngType as hiprandRngType_t;
extern "C" {
    #[must_use]
    #[doc = " \\brief Creates a new random number generator.\n\n Creates a new random number generator of type \\p rng_type,\n and returns it in \\p generator. That generator will use\n GPU to create random numbers.\n\n Values for \\p rng_type are:\n - HIPRAND_RNG_PSEUDO_DEFAULT\n - HIPRAND_RNG_PSEUDO_XORWOW\n - HIPRAND_RNG_PSEUDO_MRG32K3A\n - HIPRAND_RNG_PSEUDO_MTGP32\n - HIPRAND_RNG_PSEUDO_MT19937\n - HIPRAND_RNG_PSEUDO_PHILOX4_32_10\n - HIPRAND_RNG_QUASI_DEFAULT\n - HIPRAND_RNG_QUASI_SOBOL32\n - HIPRAND_RNG_QUASI_SCRAMBLED_SOBOL32\n - HIPRAND_RNG_QUASI_SOBOL64\n - HIPRAND_RNG_QUASI_SCRAMBLED_SOBOL64\n\n \\param generator - Pointer to generator\n \\param rng_type - Type of random number generator to create\n\n \\return\n - HIPRAND_STATUS_ALLOCATION_FAILED, if memory allocation failed \\n\n - HIPRAND_STATUS_INITIALIZATION_FAILED if there was a problem setting up the GPU \\n\n - HIPRAND_STATUS_VERSION_MISMATCH if the header file version does not match the\n   dynamically linked library version \\n\n - HIPRAND_STATUS_TYPE_ERROR if the value for \\p rng_type is invalid \\n\n - HIPRAND_STATUS_NOT_IMPLEMENTED if generator of type \\p rng_type is not implemented yet \\n\n - HIPRAND_STATUS_SUCCESS if generator was created successfully \\n\n"]
    pub fn hiprandCreateGenerator(
        generator: *mut hiprandGenerator_t,
        rng_type: hiprandRngType_t,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Creates a new random number generator on host.\n\n Creates a new host random number generator of type \\p rng_type\n and returns it in \\p generator. Created generator will use\n host CPU to generate random numbers.\n\n Values for \\p rng_type are:\n - HIPRAND_RNG_PSEUDO_DEFAULT\n - HIPRAND_RNG_PSEUDO_XORWOW\n - HIPRAND_RNG_PSEUDO_MRG32K3A\n - HIPRAND_RNG_PSEUDO_MTGP32\n - HIPRAND_RNG_PSEUDO_MT19937\n - HIPRAND_RNG_PSEUDO_PHILOX4_32_10\n - HIPRAND_RNG_QUASI_DEFAULT\n - HIPRAND_RNG_QUASI_SOBOL32\n - HIPRAND_RNG_QUASI_SCRAMBLED_SOBOL32\n - HIPRAND_RNG_QUASI_SOBOL64\n - HIPRAND_RNG_QUASI_SCRAMBLED_SOBOL64\n\n \\param generator - Pointer to generator\n \\param rng_type - Type of random number generator to create\n\n \\return\n - HIPRAND_STATUS_ALLOCATION_FAILED, if memory allocation failed \\n\n - HIPRAND_STATUS_VERSION_MISMATCH if the header file version does not match the\n   dynamically linked library version \\n\n - HIPRAND_STATUS_TYPE_ERROR if the value for \\p rng_type is invalid \\n\n - HIPRAND_STATUS_NOT_IMPLEMENTED if host generator of type \\p rng_type is not implemented yet \\n\n - HIPRAND_STATUS_SUCCESS if generator was created successfully \\n"]
    pub fn hiprandCreateGeneratorHost(
        generator: *mut hiprandGenerator_t,
        rng_type: hiprandRngType_t,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Destroys random number generator.\n\n Destroys random number generator and frees related memory.\n\n \\param generator - Generator to be destroyed\n\n \\return\n - HIPRAND_STATUS_NOT_INITIALIZED if the generator was not initialized \\n\n - HIPRAND_STATUS_SUCCESS if generator was destroyed successfully \\n"]
    pub fn hiprandDestroyGenerator(generator: hiprandGenerator_t) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Generates uniformly distributed 32-bit unsigned integers.\n\n Generates \\p n uniformly distributed 32-bit unsigned integers and\n saves them to \\p output_data.\n\n Generated numbers are between \\p 0 and \\p 2^32, including \\p 0 and\n excluding \\p 2^32.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of 32-bit unsigned integers to generate\n\n Note: \\p generator must be not be of type \\p HIPRAND_RNG_QUASI_SOBOL64\n or \\p HIPRAND_RNG_QUASI_SCRAMBLED_SOBOL64.\n\n \\return\n - HIPRAND_STATUS_NOT_INITIALIZED if the generator was not initialized \\n\n - HIPRAND_STATUS_LAUNCH_FAILURE if generator failed to launch kernel \\n\n - HIPRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn hiprandGenerate(
        generator: hiprandGenerator_t,
        output_data: *mut ::std::os::raw::c_uint,
        n: usize,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Generates uniformly distributed 8-bit unsigned integers.\n\n Generates \\p n uniformly distributed 8-bit unsigned integers and\n saves them to \\p output_data.\n\n Generated numbers are between \\p 0 and \\p 2^8, including \\p 0 and\n excluding \\p 2^8.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of 8-bit unsigned integers to generate\n\n \\return\n - HIPRAND_STATUS_NOT_INITIALIZED if the generator was not initialized \\n\n - HIPRAND_STATUS_LAUNCH_FAILURE if generator failed to launch kernel \\n\n - HIPRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn hiprandGenerateChar(
        generator: hiprandGenerator_t,
        output_data: *mut ::std::os::raw::c_uchar,
        n: usize,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Generates uniformly distributed 16-bit unsigned integers.\n\n Generates \\p n uniformly distributed 16-bit unsigned integers and\n saves them to \\p output_data.\n\n Generated numbers are between \\p 0 and \\p 2^16, including \\p 0 and\n excluding \\p 2^16.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of 16-bit unsigned integers to generate\n\n \\return\n - HIPRAND_STATUS_NOT_INITIALIZED if the generator was not initialized \\n\n - HIPRAND_STATUS_LAUNCH_FAILURE if generator failed to launch kernel \\n\n - HIPRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn hiprandGenerateShort(
        generator: hiprandGenerator_t,
        output_data: *mut ::std::os::raw::c_ushort,
        n: usize,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Generates uniformly distributed 64-bit unsigned integers.\n\n Generates \\p n uniformly distributed 64-bit unsigned integers and\n saves them to \\p output_data.\n\n Generated numbers are between \\p 0 and \\p 2^64, including \\p 0 and\n excluding \\p 2^64.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of 64-bit unsigned integers to generate\n\n Note: \\p generator must be of type \\p HIPRAND_RNG_QUASI_SOBOL64\n or \\p HIPRAND_RNG_QUASI_SCRAMBLED_SOBOL64.\n\n \\return\n - HIPRAND_STATUS_NOT_INITIALIZED if the generator was not initialized \\n\n - HIPRAND_STATUS_LAUNCH_FAILURE if generator failed to launch kernel \\n\n - HIPRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn hiprandGenerateLongLong(
        generator: hiprandGenerator_t,
        output_data: *mut ::std::os::raw::c_ulonglong,
        n: usize,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Generates uniformly distributed floats.\n\n Generates \\p n uniformly distributed 32-bit floating-point values\n and saves them to \\p output_data.\n\n Generated numbers are between \\p 0.0f and \\p 1.0f, excluding \\p 0.0f and\n including \\p 1.0f.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of floats to generate\n\n \\return\n - HIPRAND_STATUS_NOT_INITIALIZED if the generator was not initialized \\n\n - HIPRAND_STATUS_LAUNCH_FAILURE if generator failed to launch kernel \\n\n - HIPRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - HIPRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn hiprandGenerateUniform(
        generator: hiprandGenerator_t,
        output_data: *mut f32,
        n: usize,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Generates uniformly distributed double-precision floating-point values.\n\n Generates \\p n uniformly distributed 64-bit double-precision floating-point\n values and saves them to \\p output_data.\n\n Generated numbers are between \\p 0.0 and \\p 1.0, excluding \\p 0.0 and\n including \\p 1.0.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of floats to generate\n\n Note: When \\p generator is of type: \\p HIPRAND_RNG_PSEUDO_MRG32K3A,\n \\p HIPRAND_RNG_PSEUDO_MTGP32, \\p HIPRAND_RNG_QUASI_SOBOL32, or\n \\p HIPRAND_RNG_QUASI_SCRAMBLED_SOBOL32 then the returned \\p double\n values are generated from only 32 random bits\n each (one <tt>unsigned int</tt> value per one generated \\p double).\n\n \\return\n - HIPRAND_STATUS_NOT_INITIALIZED if the generator was not initialized \\n\n - HIPRAND_STATUS_LAUNCH_FAILURE if generator failed to launch kernel \\n\n - HIPRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - HIPRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn hiprandGenerateUniformDouble(
        generator: hiprandGenerator_t,
        output_data: *mut f64,
        n: usize,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Generates uniformly distributed half-precision floating-point values.\n\n Generates \\p n uniformly distributed 16-bit half-precision floating-point\n values and saves them to \\p output_data.\n\n Generated numbers are between \\p 0.0 and \\p 1.0, excluding \\p 0.0 and\n including \\p 1.0.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of halfs to generate\n\n \\return\n - HIPRAND_STATUS_NOT_INITIALIZED if the generator was not initialized \\n\n - HIPRAND_STATUS_LAUNCH_FAILURE if generator failed to launch kernel \\n\n - HIPRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - HIPRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn hiprandGenerateUniformHalf(
        generator: hiprandGenerator_t,
        output_data: *mut half,
        n: usize,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Generates normally distributed floats.\n\n Generates \\p n normally distributed 32-bit floating-point\n values and saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of floats to generate\n \\param mean - Mean value of normal distribution\n \\param stddev - Standard deviation value of normal distribution\n\n \\return\n - HIPRAND_STATUS_NOT_INITIALIZED if the generator was not initialized \\n\n - HIPRAND_STATUS_LAUNCH_FAILURE if generator failed to launch kernel \\n\n - HIPRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not even, \\p output_data is not\n aligned to \\p sizeof(float2) bytes, or \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - HIPRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn hiprandGenerateNormal(
        generator: hiprandGenerator_t,
        output_data: *mut f32,
        n: usize,
        mean: f32,
        stddev: f32,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Generates normally distributed doubles.\n\n Generates \\p n normally distributed 64-bit double-precision floating-point\n numbers and saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of doubles to generate\n \\param mean - Mean value of normal distribution\n \\param stddev - Standard deviation value of normal distribution\n\n \\return\n - HIPRAND_STATUS_NOT_INITIALIZED if the generator was not initialized \\n\n - HIPRAND_STATUS_LAUNCH_FAILURE if generator failed to launch kernel \\n\n - HIPRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not even, \\p output_data is not\n aligned to \\p sizeof(double2) bytes, or \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - HIPRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn hiprandGenerateNormalDouble(
        generator: hiprandGenerator_t,
        output_data: *mut f64,
        n: usize,
        mean: f64,
        stddev: f64,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Generates normally distributed halfs.\n\n Generates \\p n normally distributed 16-bit half-precision floating-point\n numbers and saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of halfs to generate\n \\param mean - Mean value of normal distribution\n \\param stddev - Standard deviation value of normal distribution\n\n \\return\n - HIPRAND_STATUS_NOT_INITIALIZED if the generator was not initialized \\n\n - HIPRAND_STATUS_LAUNCH_FAILURE if generator failed to launch kernel \\n\n - HIPRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not even, \\p output_data is not\n aligned to \\p sizeof(half2) bytes, or \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - HIPRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn hiprandGenerateNormalHalf(
        generator: hiprandGenerator_t,
        output_data: *mut half,
        n: usize,
        mean: half,
        stddev: half,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Generates log-normally distributed floats.\n\n Generates \\p n log-normally distributed 32-bit floating-point values\n and saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of floats to generate\n \\param mean - Mean value of log normal distribution\n \\param stddev - Standard deviation value of log normal distribution\n\n \\return\n - HIPRAND_STATUS_NOT_INITIALIZED if the generator was not initialized \\n\n - HIPRAND_STATUS_LAUNCH_FAILURE if generator failed to launch kernel \\n\n - HIPRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not even, \\p output_data is not\n aligned to \\p sizeof(float2) bytes, or \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - HIPRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn hiprandGenerateLogNormal(
        generator: hiprandGenerator_t,
        output_data: *mut f32,
        n: usize,
        mean: f32,
        stddev: f32,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Generates log-normally distributed doubles.\n\n Generates \\p n log-normally distributed 64-bit double-precision floating-point\n values and saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of doubles to generate\n \\param mean - Mean value of log normal distribution\n \\param stddev - Standard deviation value of log normal distribution\n\n \\return\n - HIPRAND_STATUS_NOT_INITIALIZED if the generator was not initialized \\n\n - HIPRAND_STATUS_LAUNCH_FAILURE if generator failed to launch kernel \\n\n - HIPRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not even, \\p output_data is not\n aligned to \\p sizeof(double2) bytes, or \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - HIPRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn hiprandGenerateLogNormalDouble(
        generator: hiprandGenerator_t,
        output_data: *mut f64,
        n: usize,
        mean: f64,
        stddev: f64,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Generates log-normally distributed halfs.\n\n Generates \\p n log-normally distributed 16-bit half-precision floating-point\n values and saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of halfs to generate\n \\param mean - Mean value of log normal distribution\n \\param stddev - Standard deviation value of log normal distribution\n\n \\return\n - HIPRAND_STATUS_NOT_INITIALIZED if the generator was not initialized \\n\n - HIPRAND_STATUS_LAUNCH_FAILURE if generator failed to launch kernel \\n\n - HIPRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not even, \\p output_data is not\n aligned to \\p sizeof(half2) bytes, or \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - HIPRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn hiprandGenerateLogNormalHalf(
        generator: hiprandGenerator_t,
        output_data: *mut half,
        n: usize,
        mean: half,
        stddev: half,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Generates Poisson-distributed 32-bit unsigned integers.\n\n Generates \\p n Poisson-distributed 32-bit unsigned integers and\n saves them to \\p output_data.\n\n \\param generator - Generator to use\n \\param output_data - Pointer to memory to store generated numbers\n \\param n - Number of 32-bit unsigned integers to generate\n \\param lambda - lambda for the Poisson distribution\n\n \\return\n - HIPRAND_STATUS_NOT_INITIALIZED if the generator was not initialized \\n\n - HIPRAND_STATUS_LAUNCH_FAILURE if generator failed to launch kernel \\n\n - HIPRAND_STATUS_OUT_OF_RANGE if lambda is non-positive \\n\n - HIPRAND_STATUS_LENGTH_NOT_MULTIPLE if \\p n is not a multiple of the dimension\n of used quasi-random generator \\n\n - HIPRAND_STATUS_SUCCESS if random numbers were successfully generated \\n"]
    pub fn hiprandGeneratePoisson(
        generator: hiprandGenerator_t,
        output_data: *mut ::std::os::raw::c_uint,
        n: usize,
        lambda: f64,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Initializes the generator's state on GPU or host.\n\n Initializes the generator's state on GPU or host.\n\n If hiprandGenerateSeeds() was not called for a generator, it will be\n automatically called by functions which generates random numbers like\n hiprandGenerate(), hiprandGenerateUniform(), hiprandGenerateNormal() etc.\n\n \\param generator - Generator to initialize\n\n \\return\n - HIPRAND_STATUS_NOT_INITIALIZED if the generator was never created \\n\n - HIPRAND_STATUS_PREEXISTING_FAILURE if there was an existing error from\n   a previous kernel launch \\n\n - HIPRAND_STATUS_LAUNCH_FAILURE if the kernel launch failed for any reason \\n\n - HIPRAND_STATUS_SUCCESS if the seeds were generated successfully \\n"]
    pub fn hiprandGenerateSeeds(generator: hiprandGenerator_t) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Sets the current stream for kernel launches.\n\n Sets the current stream for all kernel launches of the generator.\n All functions will use this stream.\n\n \\param generator - Generator to modify\n \\param stream - Stream to use or NULL for default stream\n\n \\return\n - HIPRAND_STATUS_NOT_INITIALIZED if the generator was not initialized \\n\n - HIPRAND_STATUS_SUCCESS if stream was set successfully \\n"]
    pub fn hiprandSetStream(generator: hiprandGenerator_t, stream: hipStream_t) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Sets the seed of a pseudo-random number generator.\n\n Sets the seed of the pseudo-random number generator.\n\n - This operation resets the generator's internal state.\n - This operation does not change the generator's offset.\n\n \\param generator - Pseudo-random number generator\n \\param seed - New seed value\n\n \\return\n - HIPRAND_STATUS_NOT_INITIALIZED if the generator was not initialized \\n\n - HIPRAND_STATUS_TYPE_ERROR if the generator is a quasi random number generator \\n\n - HIPRAND_STATUS_SUCCESS if seed was set successfully \\n"]
    pub fn hiprandSetPseudoRandomGeneratorSeed(
        generator: hiprandGenerator_t,
        seed: ::std::os::raw::c_ulonglong,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Sets the offset of a random number generator.\n\n Sets the absolute offset of the random number generator.\n\n - This operation resets the generator's internal state.\n - This operation does not change the generator's seed.\n\n Absolute offset cannot be set if generator's type is\n HIPRAND_RNG_PSEUDO_MTGP32 or HIPRAND_RNG_PSEUDO_MT19937.\n\n \\param generator - Random number generator\n \\param offset - New absolute offset\n\n \\return\n - HIPRAND_STATUS_NOT_INITIALIZED if the generator was not initialized \\n\n - HIPRAND_STATUS_SUCCESS if offset was successfully set \\n\n - HIPRAND_STATUS_TYPE_ERROR if generator's type is HIPRAND_RNG_PSEUDO_MTGP32\n or HIPRAND_RNG_PSEUDO_MT19937 \\n"]
    pub fn hiprandSetGeneratorOffset(
        generator: hiprandGenerator_t,
        offset: ::std::os::raw::c_ulonglong,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Set the number of dimensions of a quasi-random number generator.\n\n Set the number of dimensions of a quasi-random number generator.\n Supported values of \\p dimensions are 1 to 20000.\n\n - This operation resets the generator's internal state.\n - This operation does not change the generator's offset.\n\n \\param generator - Quasi-random number generator\n \\param dimensions - Number of dimensions\n\n \\return\n - HIPRAND_STATUS_NOT_CREATED if the generator wasn't created \\n\n - HIPRAND_STATUS_TYPE_ERROR if the generator is not a quasi-random number generator \\n\n - HIPRAND_STATUS_OUT_OF_RANGE if \\p dimensions is out of range \\n\n - HIPRAND_STATUS_SUCCESS if the number of dimensions was set successfully \\n"]
    pub fn hiprandSetQuasiRandomGeneratorDimensions(
        generator: hiprandGenerator_t,
        dimensions: ::std::os::raw::c_uint,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Returns the version number of the cuRAND or rocRAND library.\n\n Returns in \\p version the version number of the underlying cuRAND or\n rocRAND library.\n\n \\param version - Version of the library\n\n \\return\n - HIPRAND_STATUS_OUT_OF_RANGE if \\p version is NULL \\n\n - HIPRAND_STATUS_SUCCESS if the version number was successfully returned \\n"]
    pub fn hiprandGetVersion(version: *mut ::std::os::raw::c_int) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Construct the histogram for a Poisson distribution.\n\n Construct the histogram for the Poisson distribution with lambda \\p lambda.\n\n \\param lambda - lambda for the Poisson distribution\n \\param discrete_distribution - pointer to the histogram in device memory\n\n \\return\n - HIPRAND_STATUS_ALLOCATION_FAILED if memory could not be allocated \\n\n - HIPRAND_STATUS_OUT_OF_RANGE if \\p discrete_distribution pointer was null \\n\n - HIPRAND_STATUS_OUT_OF_RANGE if lambda is non-positive \\n\n - HIPRAND_STATUS_SUCCESS if the histogram was constructed successfully \\n"]
    pub fn hiprandCreatePoissonDistribution(
        lambda: f64,
        discrete_distribution: *mut hiprandDiscreteDistribution_t,
    ) -> hiprandStatus_t;
}
extern "C" {
    #[must_use]
    #[doc = " \\brief Destroy the histogram array for a discrete distribution.\n\n Destroy the histogram array for a discrete distribution created by\n hiprandCreatePoissonDistribution.\n\n \\param discrete_distribution - pointer to the histogram in device memory\n\n \\return\n - HIPRAND_STATUS_OUT_OF_RANGE if \\p discrete_distribution was null \\n\n - HIPRAND_STATUS_SUCCESS if the histogram was destroyed successfully \\n"]
    pub fn hiprandDestroyDistribution(
        discrete_distribution: hiprandDiscreteDistribution_t,
    ) -> hiprandStatus_t;
}
